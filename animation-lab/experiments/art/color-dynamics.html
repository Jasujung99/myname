<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìƒ‰ì±„ ë™ì—­í•™ - ìƒ‰ê³µê°„ íƒí—˜</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --primary-color: #1a1a1a;
            --secondary-color: #2a2a2a;
            --text-color: #e0e0e0;
            --accent-color: #4ecdc4;
            --button-bg: #333;
            --button-hover: #555;
            --grid-color: #333;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, var(--bg-color) 0%, #1a1a2e 50%,                    this.ctx.globalAlpha = finalAlpha;
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.ctx.globalAlpha = 1; // ì›ë˜ëŒ€ë¡œ ë³µì›3e 100%);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            min-height: 0;
        }
        
        .canvas-section {
            flex: 1;
            background: rgba(26, 26, 26, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #333;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        
        .canvas-section h3 {
            color: var(--accent-color);
            margin-bottom: 10px;
            font-size: 1.1rem;
            flex-shrink: 0;
        }
        
        canvas {
            width: 100%;
            flex: 1;
            min-height: 200px;
            background: var(--primary-color);
            border-radius: 8px;
            border: 1px solid var(--grid-color);
            cursor: crosshair;
        }
        
        .controls {
            width: 380px;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }
        
        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .back-button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .back-button:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.3);
        }

        .control-header h1 {
            font-size: 1.5rem;
            color: var(--accent-color);
            margin-bottom: 5px;
        }
        
        .control-header p {
            color: #999;
            font-size: 0.9rem;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .control-value {
            color: var(--accent-color);
            font-family: 'Courier New', monospace;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--secondary-color);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--accent-color);
        }
        
        .color-modes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .mode-button {
            padding: 8px 12px;
            background: var(--button-bg);
            color: var(--text-color);
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
        }
        
        .mode-button:hover {
            background: var(--button-hover);
            border-color: var(--accent-color);
        }
        
        .mode-button.active {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: #000;
        }
        
        .harmony-types {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .harmony-types h4 {
            color: var(--accent-color);
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .harmony-button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            background: var(--button-bg);
            color: var(--text-color);
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }
        
        .harmony-button:hover {
            background: var(--button-hover);
            border-color: var(--accent-color);
        }
        
        .harmony-button.active {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: #000;
        }
        
        .color-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .color-display h4 {
            color: var(--accent-color);
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .color-swatch {
            width: 100%;
            height: 80px;
            border-radius: 8px;
            border: 2px solid #444;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .color-info {
            font-size: 0.85rem;
            color: #ccc;
            line-height: 1.4;
        }
        
        .info-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .info-section h4 {
            color: var(--accent-color);
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .info-section p {
            font-size: 0.85rem;
            line-height: 1.5;
            color: #ccc;
            margin-bottom: 8px;
        }
        
        .export-button {
            background: var(--accent-color);
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            width: 100%;
            margin-top: 10px;
        }
        
        .export-button:hover {
            background: #3db8b4;
            transform: translateY(-1px);
        }
        
        .export-button:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .controls {
                width: 100%;
                height: auto;
                max-height: 40vh;
            }
            
            .canvas-area {
                height: 60vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-area">
            <div class="canvas-section">
                <h3>ğŸ¨ ìƒ‰ì±„ ë™ì—­í•™ íƒí—˜</h3>
                <canvas id="colorCanvas"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <div class="nav-header">
                <a href="../../index.html" class="back-button">
                    â† ëŒì•„ê°€ê¸°
                </a>
                <div class="control-header">
                    <h1>ìƒ‰ì±„ ë™ì—­í•™</h1>
                    <p>ìƒ‰ê³µê°„ì„ ì—¬í–‰í•˜ë©° ë°œê²¬í•˜ëŠ” ìƒ‰ì˜ ë¬´í•œí•œ ê°€ëŠ¥ì„±</p>
                </div>
            </div>
            
            <div class="color-modes">
                <button class="mode-button active" data-mode="wheel">ìƒ‰ìƒí™˜</button>
                <button class="mode-button" data-mode="palette">ìƒ‰ì±„ íŒ”ë ˆíŠ¸</button>
                <button class="mode-button" data-mode="gradient">ê·¸ë¼ë””ì–¸íŠ¸</button>
                <button class="mode-button" data-mode="interactive">ì¸í„°ë™í‹°ë¸Œ</button>
            </div>
            
            <div class="mode-info" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 0.8rem; color: #ccc;">
                <span id="modeDescription">ìƒ‰ìƒí™˜: ì›í˜• HSL ìƒ‰ê³µê°„ì—ì„œ ì¡°í™”ìƒ‰ì„ íƒí—˜í•´ë³´ì„¸ìš”</span>
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <span>ìƒ‰ìƒ (H)</span>
                    <span class="control-value" id="hueValue">200Â°</span>
                </div>
                <input type="range" id="hue" min="0" max="360" step="1" value="200">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <span>ì±„ë„ (S)</span>
                    <span class="control-value" id="saturationValue">70%</span>
                </div>
                <input type="range" id="saturation" min="0" max="100" step="1" value="70">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <span>ëª…ë„ (L)</span>
                    <span class="control-value" id="lightnessValue">60%</span>
                </div>
                <input type="range" id="lightness" min="0" max="100" step="1" value="60">
            </div>
            
            <div class="harmony-types">
                <h4>ğŸ­ ìƒ‰ì±„ ì¡°í™”</h4>
                <button class="harmony-button active" data-harmony="complementary">ë³´ìƒ‰ (180Â°)</button>
                <button class="harmony-button" data-harmony="triadic">ì‚¼ê°ìƒ‰ (120Â°)</button>
                <button class="harmony-button" data-harmony="tetradic">ì‚¬ê°ìƒ‰ (90Â°)</button>
                <button class="harmony-button" data-harmony="analogous">ìœ ì‚¬ìƒ‰ (30Â°)</button>
                <button class="harmony-button" data-harmony="split">ë¶„í• ë³´ìƒ‰ (150Â°)</button>
                <button class="harmony-button" data-harmony="monochromatic">ë‹¨ìƒ‰ ì¡°í™”</button>
            </div>
            
            <div class="color-display">
                <h4>ğŸ¨ í˜„ì¬ ìƒ‰ìƒ</h4>
                <div class="color-swatch" id="currentColor">HSL(200Â°, 70%, 60%)</div>
                <div class="color-info" id="colorInfo">
                    <strong>HSL:</strong> 200Â°, 70%, 60%<br>
                    <strong>RGB:</strong> 77, 166, 204<br>
                    <strong>HEX:</strong> #4DA6CC
                </div>
                <button id="exportBtn" class="export-button" style="display: none;">PNGë¡œ ì €ì¥</button>
            </div>
            

            
            <div class="info-section">
                <h4>ğŸ“š ìƒ‰ì±„ ì´ë¡ </h4>
                <p><strong>ìƒ‰ìƒí™˜(Hue):</strong> 0Â°-360Â°ì˜ ìƒ‰ìƒ ìŠ¤í™íŠ¸ëŸ¼ìœ¼ë¡œ ìƒ‰ì˜ ì¢…ë¥˜ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.</p>
                <p><strong>ì±„ë„(Saturation):</strong> ìƒ‰ì˜ ìˆœìˆ˜í•¨ê³¼ ì„ ëª…ë„ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.</p>
                <p><strong>ëª…ë„(Lightness):</strong> ìƒ‰ì˜ ë°ê¸°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.</p>
                <p><strong>ë³´ìƒ‰:</strong> ìƒ‰ìƒí™˜ì—ì„œ 180Â° ëŒ€ì¹­ì¸ ìƒ‰ìœ¼ë¡œ ê°€ì¥ ê°•í•œ ëŒ€ë¹„ë¥¼ ë§Œë“­ë‹ˆë‹¤.</p>
                <p><strong>ì‚¼ê°ìƒ‰:</strong> 120Â° ê°„ê²©ìœ¼ë¡œ ë°°ì¹˜ëœ 3ê°œì˜ ìƒ‰ìœ¼ë¡œ ê· í˜•ì¡íŒ ì¡°í™”ë¥¼ ë§Œë“­ë‹ˆë‹¤.</p>
            </div>
        </div>
    </div>
    
    <script>
        class ColorTheoryArt {
            constructor() {
                this.canvas = document.getElementById('colorCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.params = {
                    mode: 'wheel',
                    harmony: 'complementary',
                    hue: 200,
                    saturation: 70,
                    lightness: 60,
                    animationSpeed: 0.02,
                    particleCount: 50
                };
                
                this.time = 0;
                this.animationId = null;
                this.particles = [];
                this.permanentCircles = []; // í´ë¦­ìœ¼ë¡œ ì°íŒ ë³´ìƒ‰ ì›ë“¤
                this.mouseX = 0;
                this.mouseY = 0;
                
                this.initCanvas();
                this.setupControls();
                this.setupModes();
                this.setupHarmony();
                this.setupExport(); // PNG ì €ì¥ ê¸°ëŠ¥ ì¶”ê°€
                this.initParticles();
                this.updateControlsState(); // ì´ˆê¸° ì»¨íŠ¸ë¡¤ ìƒíƒœ ì„¤ì •
                this.animate();
            }
            
            initCanvas() {
                const resizeCanvas = () => {
                    const rect = this.canvas.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;
                    
                    this.canvas.width = rect.width * dpr;
                    this.canvas.height = rect.height * dpr;
                    
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    
                    this.ctx.scale(dpr, dpr);
                    
                    this.width = rect.width;
                    this.height = rect.height;
                    this.centerX = this.width / 2;
                    this.centerY = this.height / 2;
                };
                
                setTimeout(resizeCanvas, 100);
                window.addEventListener('resize', () => setTimeout(resizeCanvas, 100));
                
                // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('click', (e) => {
                    this.handleCanvasClick(e);
                });
            }
            
            handleCanvasClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.params.mode === 'wheel') {
                    // ìƒ‰ìƒí™˜ì—ì„œ í´ë¦­í•œ ìœ„ì¹˜ì˜ ìƒ‰ìƒ ì¶”ì¶œ
                    const dx = x - this.centerX;
                    const dy = y - this.centerY;
                    const angle = Math.atan2(dy, dx);
                    const hue = ((angle * 180 / Math.PI) + 360) % 360;
                    
                    this.params.hue = hue;
                    document.getElementById('hue').value = hue;
                    document.getElementById('hueValue').textContent = Math.round(hue) + 'Â°';
                    this.updateColorDisplay();
                } else if (this.params.mode === 'interactive') {
                    // ì¸í„°ë™í‹°ë¸Œ ëª¨ë“œì—ì„œ ë³´ìƒ‰ ì› ë„ì¥ ì°ê¸°
                    this.addPermanentCircle(x, y);
                }
            }
            
            setupControls() {
                const controls = {
                    hue: { element: 'hue', display: 'hueValue', unit: 'Â°' },
                    saturation: { element: 'saturation', display: 'saturationValue', unit: '%' },
                    lightness: { element: 'lightness', display: 'lightnessValue', unit: '%' }
                };
                
                Object.entries(controls).forEach(([param, config]) => {
                    const element = document.getElementById(config.element);
                    const display = document.getElementById(config.display);
                    
                    element.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.params[param] = value;
                        display.textContent = Math.round(value) + config.unit;
                        this.updateColorDisplay();
                    });
                    
                    display.textContent = Math.round(element.value) + config.unit;
                });
            }
            
            setupModes() {
                const buttons = document.querySelectorAll('.mode-button');
                
                buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        buttons.forEach(b => b.classList.remove('active'));
                        button.classList.add('active');
                        this.params.mode = button.dataset.mode;
                        this.updateControlsState(); // ì»¨íŠ¸ë¡¤ ìƒíƒœ ì—…ë°ì´íŠ¸
                    });
                });
            }
            
            // ëª¨ë“œì— ë”°ë¥¸ ì»¨íŠ¸ë¡¤ í™œì„±í™”/ë¹„í™œì„±í™”
            updateControlsState() {
                const lightnessGroup = document.querySelector('#lightness').parentElement;
                const harmonyButtons = document.querySelectorAll('.harmony-button');
                
                // íŒ”ë ˆíŠ¸ ëª¨ë“œì—ì„œ ëª…ë„ ìŠ¬ë¼ì´ë” ë¹„í™œì„±í™”
                if (this.params.mode === 'palette') {
                    lightnessGroup.style.opacity = '0.5';
                    lightnessGroup.style.pointerEvents = 'none';
                    lightnessGroup.querySelector('.control-label span').textContent = 'ëª…ë„ (ë¹„í™œì„±í™”)';
                } else {
                    lightnessGroup.style.opacity = '1';
                    lightnessGroup.style.pointerEvents = 'auto';
                    lightnessGroup.querySelector('.control-label span').textContent = 'ëª…ë„ (L)';
                }
                
                // ì¸í„°ë™í‹°ë¸Œ ëª¨ë“œì—ì„œ ì¡°í™” íƒ€ì… ì œí•œ (ë³´ìƒ‰ë§Œ)
                if (this.params.mode === 'interactive') {
                    harmonyButtons.forEach(button => {
                        if (button.dataset.harmony === 'complementary') {
                            button.style.opacity = '1';
                            button.style.pointerEvents = 'auto';
                            button.classList.add('active');
                            this.params.harmony = 'complementary';
                        } else {
                            button.style.opacity = '0.5';
                            button.style.pointerEvents = 'none';
                            button.classList.remove('active');
                        }
                    });
                } else {
                    // ë‹¤ë¥¸ ëª¨ë“œì—ì„œëŠ” ëª¨ë“  ì¡°í™” íƒ€ì… í™œì„±í™”
                    harmonyButtons.forEach(button => {
                        button.style.opacity = '1';
                        button.style.pointerEvents = 'auto';
                    });
                }
                
                // ì €ì¥ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updateExportButton();
            }
            
            setupHarmony() {
                const buttons = document.querySelectorAll('.harmony-button');
                
                buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        buttons.forEach(b => b.classList.remove('active'));
                        button.classList.add('active');
                        this.params.harmony = button.dataset.harmony;
                    });
                });
            }
            
            setupExport() {
                const exportBtn = document.getElementById('exportBtn');
                exportBtn.addEventListener('click', () => {
                    this.exportPNG();
                });
                
                // íŠ¹ì • ëª¨ë“œì—ì„œë§Œ ì €ì¥ ë²„íŠ¼ í™œì„±í™”
                this.updateExportButton();
            }
            
            updateExportButton() {
                const exportBtn = document.getElementById('exportBtn');
                const canExport = this.params.mode === 'gradient' || this.params.mode === 'interactive';
                
                if (canExport) {
                    exportBtn.style.display = 'block';
                    exportBtn.disabled = false;
                    exportBtn.textContent = 'PNGë¡œ ì €ì¥';
                } else {
                    exportBtn.style.display = 'none';
                }
            }
            
            exportPNG() {
                // í˜„ì¬ ìº”ë²„ìŠ¤ ìƒíƒœë¥¼ ì´ë¯¸ì§€ë¡œ ì €ì¥
                const link = document.createElement('a');
                const filename = `ìƒ‰ì±„ë™ì—­í•™_${this.params.mode}_${Date.now()}.png`;
                
                link.download = filename;
                link.href = this.canvas.toDataURL('image/png');
                link.click();
            }
            
            // ë³´ìƒ‰ ê·¸ë¼ë””ì–¸íŠ¸ ì˜êµ¬ ì €ì¥ (ì§„ì§œ ë„ì¥ ì°ê¸°)
            addPermanentCircle(x, y) {
                const baseColor = `hsl(${this.params.hue}, ${this.params.saturation}%, ${this.params.lightness}%)`;
                const complementaryColor = `hsl(${(this.params.hue + 180) % 360}, ${this.params.saturation}%, ${this.params.lightness}%)`;
                
                // ì¤‘ì²© íšŸìˆ˜ ê³„ì‚° (ì „ì²´ ìº”ë²„ìŠ¤ ì˜ì—­ì—ì„œ ê¸°ì¡´ í´ë¦­ë“¤)
                const canvasDiagonal = Math.sqrt(this.width ** 2 + this.height ** 2);
                const overlapCount = this.calculateOverlap(x, y, canvasDiagonal);
                
                this.permanentCircles.push({
                    x: x,
                    y: y,
                    baseColor: baseColor,
                    complementaryColor: complementaryColor,
                    radius: Math.min(this.width, this.height) * 0.4,
                    overlapCount: overlapCount // ì¤‘ì²© íšŸìˆ˜ ì €ì¥
                });
                
                // ìµœëŒ€ 100ê°œ ê·¸ë¼ë””ì–¸íŠ¸ ìœ ì§€
                if (this.permanentCircles.length > 100) {
                    this.permanentCircles.shift();
                }
            }
            
            // ì¤‘ì²© íšŸìˆ˜ ê³„ì‚° í•¨ìˆ˜
            calculateOverlap(x, y, radius) {
                let overlapCount = 0;
                this.permanentCircles.forEach(circle => {
                    const distance = Math.sqrt((x - circle.x) ** 2 + (y - circle.y) ** 2);
                    if (distance < radius) {
                        overlapCount++;
                    }
                });
                return overlapCount;
            }
            
            initParticles() {
                this.particles = [];
                for (let i = 0; i < this.params.particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: Math.random() * 3 + 1,
                        hue: Math.random() * 360,
                        life: Math.random()
                    });
                }
            }
            
            getHarmonyColors() {
                const baseHue = this.params.hue;
                const colors = [];
                
                switch (this.params.harmony) {
                    case 'complementary':
                        colors.push(baseHue, (baseHue + 180) % 360);
                        break;
                    case 'triadic':
                        colors.push(baseHue, (baseHue + 120) % 360, (baseHue + 240) % 360);
                        break;
                    case 'tetradic':
                        colors.push(baseHue, (baseHue + 90) % 360, (baseHue + 180) % 360, (baseHue + 270) % 360);
                        break;
                    case 'analogous':
                        colors.push(baseHue, (baseHue + 30) % 360, (baseHue - 30 + 360) % 360);
                        break;
                    case 'split':
                        colors.push(baseHue, (baseHue + 150) % 360, (baseHue - 150 + 360) % 360);
                        break;
                    case 'monochromatic':
                        // ë‹¨ìƒ‰ì¡°í™”: ê°™ì€ ìƒ‰ìƒì—ì„œ ì±„ë„ ë³€í™”ë¥¼ ë³´ì—¬ì¤Œ
                        colors.push(baseHue, baseHue, baseHue, baseHue, baseHue);
                        break;
                }
                
                return colors;
            }
            
            hslToRgb(h, s, l) {
                h = h / 360;
                s = s / 100;
                l = l / 100;
                
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
            
            rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            updateColorDisplay() {
                const [r, g, b] = this.hslToRgb(this.params.hue, this.params.saturation, this.params.lightness);
                const hex = this.rgbToHex(r, g, b);
                const hsl = `hsl(${Math.round(this.params.hue)}, ${Math.round(this.params.saturation)}%, ${Math.round(this.params.lightness)}%)`;
                
                const colorSwatch = document.getElementById('currentColor');
                const colorInfo = document.getElementById('colorInfo');
                
                colorSwatch.style.backgroundColor = hsl;
                colorSwatch.textContent = `HSL(${Math.round(this.params.hue)}Â°, ${Math.round(this.params.saturation)}%, ${Math.round(this.params.lightness)}%)`;
                
                colorInfo.innerHTML = `
                    <strong>HSL:</strong> ${Math.round(this.params.hue)}Â°, ${Math.round(this.params.saturation)}%, ${Math.round(this.params.lightness)}%<br>
                    <strong>RGB:</strong> ${r}, ${g}, ${b}<br>
                    <strong>HEX:</strong> ${hex}
                `;
            }
            
            drawColorWheel() {
                const radius = Math.min(this.width, this.height) * 0.35;
                const imageData = this.ctx.createImageData(this.width, this.height);
                const data = imageData.data;
                
                for (let y = 0; y < this.height; y += 2) {
                    for (let x = 0; x < this.width; x += 2) {
                        const dx = x - this.centerX;
                        const dy = y - this.centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < radius) {
                            const angle = Math.atan2(dy, dx);
                            const hue = ((angle * 180 / Math.PI) + 360) % 360;
                            const saturation = (distance / radius) * 100;
                            const lightness = this.params.lightness;
                            
                            const [r, g, b] = this.hslToRgb(hue, saturation, lightness);
                            
                            const index = (y * this.width + x) * 4;
                            data[index] = r;
                            data[index + 1] = g;
                            data[index + 2] = b;
                            data[index + 3] = 255;
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                
                // ì¡°í™” ìƒ‰ìƒ í‘œì‹œ
                const harmonyColors = this.getHarmonyColors();
                harmonyColors.forEach((hue, index) => {
                    const angle = hue * Math.PI / 180;
                    
                    let saturation, lightness;
                    
                    // ë‹¨ìƒ‰ì¡°í™”ì¼ ë•ŒëŠ” ì±„ë„/ëª…ë„ ë³€í™”ë¡œ í‘œí˜„
                    if (this.params.harmony === 'monochromatic') {
                        saturation = Math.max(20, this.params.saturation - index * 15); // ì±„ë„ ë³€í™”
                        lightness = this.params.lightness + (index - 2) * 10; // ëª…ë„ ë³€í™”
                        lightness = Math.max(20, Math.min(80, lightness));
                    } else {
                        saturation = this.params.saturation;
                        lightness = this.params.lightness;
                    }
                    
                    // ì±„ë„ì— ë”°ë¼ ë°˜ì§€ë¦„ ì¡°ì • (0% = ì¤‘ì‹¬, 100% = ê°€ì¥ìë¦¬)
                    const adjustedRadius = radius * (saturation / 100);
                    const x = this.centerX + Math.cos(angle) * adjustedRadius;
                    const y = this.centerY + Math.sin(angle) * adjustedRadius;
                    
                    this.ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 12, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
            }
            
            drawColorPalette() {
                const harmonyColors = this.getHarmonyColors();
                const paletteWidth = this.width * 0.8;
                const paletteHeight = this.height * 0.6;
                const startX = (this.width - paletteWidth) / 2;
                const startY = (this.height - paletteHeight) / 2;
                const colorWidth = paletteWidth / harmonyColors.length;
                
                harmonyColors.forEach((hue, index) => {
                    const x = startX + index * colorWidth;
                    
                    // ëª…ë„ ê·¸ë¼ë””ì–¸íŠ¸
                    for (let i = 0; i < paletteHeight; i++) {
                        const lightness = 100 - (i / paletteHeight) * 100;
                        const color = `hsl(${hue}, ${this.params.saturation}%, ${lightness}%)`;
                        
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(x, startY + i, colorWidth, 1);
                    }
                    
                    // ìƒ‰ìƒ ì •ë³´ í‘œì‹œ
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`${Math.round(hue)}Â°`, x + colorWidth / 2, startY + paletteHeight + 20);
                });
            }
            
            drawGradient() {
                const harmonyColors = this.getHarmonyColors();
                const gradient = this.ctx.createLinearGradient(0, 0, this.width, this.height);
                
                harmonyColors.forEach((hue, index) => {
                    const position = index / Math.max(1, harmonyColors.length - 1);
                    const color = `hsl(${hue}, ${this.params.saturation}%, ${this.params.lightness}%)`;
                    gradient.addColorStop(position, color);
                });
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
            }
            
            drawInteractive() {
                // ê¸°ë³¸ ë°°ê²½
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ì˜êµ¬ ì €ì¥ëœ ê·¸ë¼ë””ì–¸íŠ¸ë“¤ ê·¸ë¦¬ê¸° (ì¤‘ì²© íšŸìˆ˜ ê¸°ë°˜ ê°•ë„)
                this.permanentCircles.forEach(circle => {
                    const gradient = this.ctx.createRadialGradient(
                        circle.x, circle.y, 0,
                        circle.x, circle.y, circle.radius
                    );
                    
                    gradient.addColorStop(0, circle.baseColor);
                    gradient.addColorStop(1, circle.complementaryColor);
                    
                    // ì¤‘ì²© íšŸìˆ˜ì— ë”°ë¼ íˆ¬ëª…ë„ ì¦ê°€ (0.2 ê¸°ë³¸ + ì¤‘ì²©ë‹¹ 0.1ì”© ì¦ê°€)
                    const baseAlpha = 0.2;
                    const overlapBonus = circle.overlapCount * 0.1; // ë‹¤ì‹œ 0.1ë¡œ ë³µêµ¬
                    const finalAlpha = Math.min(baseAlpha + overlapBonus, 1.0);
                    
                    this.ctx.globalAlpha = finalAlpha;
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.ctx.globalAlpha = 1; // ì›ë˜ëŒ€ë¡œ ë³µì›
                });
                
                // í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì˜ ì‹¤ì‹œê°„ ê·¸ë¼ë””ì–¸íŠ¸ (ì˜¤ë²„ë ˆì´)
                const currentGradient = this.ctx.createRadialGradient(
                    this.mouseX, this.mouseY, 0,
                    this.mouseX, this.mouseY, Math.min(this.width, this.height) * 0.4
                );
                
                const baseColor = `hsl(${this.params.hue}, ${this.params.saturation}%, ${this.params.lightness}%)`;
                const complementaryColor = `hsl(${(this.params.hue + 180) % 360}, ${this.params.saturation}%, ${this.params.lightness}%)`;
                
                currentGradient.addColorStop(0, baseColor);
                currentGradient.addColorStop(1, complementaryColor);
                
                // ë°˜íˆ¬ëª…ìœ¼ë¡œ ì˜¤ë²„ë ˆì´
                this.ctx.globalAlpha = 0.2;
                this.ctx.fillStyle = currentGradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                this.ctx.globalAlpha = 1;
            }
            
            draw() {
                if (!this.width || !this.height) return;
                
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                switch (this.params.mode) {
                    case 'wheel':
                        this.drawColorWheel();
                        break;
                    case 'palette':
                        this.drawColorPalette();
                        break;
                    case 'gradient':
                        this.drawGradient();
                        break;
                    case 'interactive':
                        this.drawInteractive();
                        break;
                }
            }
            
            animate() {
                this.draw();
                this.time += this.params.animationSpeed;
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }
        
        // ì´ˆê¸°í™”
        let colorTheoryArt;
        window.addEventListener('load', () => {
            colorTheoryArt = new ColorTheoryArt();
            colorTheoryArt.updateColorDisplay();
        });
    </script>
</body>
</html>
