<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIR 전염병 모델 - 풀스크린 모드</title>
    <script src="https://cdn.jsdelivr.net/npm/vega@5.22.1/build/vega.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.6.0/build/vega-lite.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.21.0/build/vega-embed.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #050510;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* 전체 화면 시뮬레이션 영역 */
        .simulation-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #0d0d1d 0%, #050510 100%);
            z-index: 0;
        }
        
        /* 개별 에이전트 컨테이너 */
        .agent {
            position: absolute;
            width: 50px;
            height: 50px;
            pointer-events: none;
            transition: none;
        }
        
        /* 떠 있는 모달 카드 */
        .floating-card {
            position: absolute;
            background: rgba(30, 30, 40, 0.75);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 20px;
            color: white;
            z-index: 1000;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: all 0.3s ease;
        }
        
        .floating-card:hover {
            background: rgba(40, 40, 50, 0.85);
            box-shadow: 0 12px 42px rgba(0, 0, 0, 0.4);
        }
        
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .card-header h3 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .card-header .icon {
            font-size: 1.4rem;
        }
        
        .card-toggle {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .card-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .card-content {
            transition: max-height 0.3s ease;
            overflow: hidden;
        }
        
        .card-content.collapsed {
            max-height: 0;
        }
        
        /* 카드 위치 */
        .controls-card {
            top: 20px;
            left: 20px;
            width: 280px;
        }
        
        .stats-card {
            top: 20px;
            right: 20px;
            width: 240px;
        }
        
        .guide-card {
            top: 20px;
            left: 320px;
            width: 320px;
        }
        
        /* 드래그 가능한 요소 */
        .draggable {
            cursor: move;
        }
        
        /* 범례 */
        .status-legend {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
        }
        
        .status-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .susceptible { background: #0ea5e9; }
        .infected { background: #ef4444; }
        .recovered { background: #22c55e; }
        
        /* 파라미터 컨트롤 */
        .param-control {
            margin-bottom: 16px;
        }
        
        .param-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }
        
        .param-label {
            color: #ccc;
        }
        
        .param-value {
            color: #4a9eff;
            font-weight: 500;
        }
        
        .param-control input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            margin: 8px 0;
        }
        
        .param-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid rgba(0, 0, 0, 0.3);
        }
        
        /* 버튼 */
        .button-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #22c55e, #16a34a);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #4a9eff, #4860e9);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 158, 255, 0.4);
        }
        
        /* 통계 섹션 */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
        }
        
        /* 가이드 섹션 */
        .guide-content {
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        .guide-content p {
            margin-bottom: 12px;
        }
        
        .guide-content ul {
            padding-left: 20px;
            margin: 10px 0;
        }
        
        .guide-content li {
            margin-bottom: 6px;
        }
        
        .highlight {
            color: #4a9eff;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <!-- 전체 화면 시뮬레이션 영역 -->
    <div class="simulation-area" id="simulation-area">
        <!-- 에이전트들이 여기에 동적으로 추가됩니다 -->
    </div>
    
    <!-- 컨트롤 패널 (좌상단) -->
    <div class="floating-card controls-card draggable" id="controls-card">
        <div class="card-header">
            <h3><span class="icon">🎛️</span> 시뮬레이션 제어</h3>
            <button class="card-toggle" id="toggle-controls">−</button>
        </div>
        <div class="card-content" id="controls-content">
            <div class="status-legend">
                <div class="status-item">
                    <div class="status-color susceptible"></div>
                    <span>감수성자</span>
                </div>
                <div class="status-item">
                    <div class="status-color infected"></div>
                    <span>감염자</span>
                </div>
                <div class="status-item">
                    <div class="status-color recovered"></div>
                    <span>회복자</span>
                </div>
            </div>
            
            <div class="param-control">
                <div class="param-header">
                    <span class="param-label">인구수</span>
                    <span class="param-value" id="population-value">50</span>
                </div>
                <input type="range" id="population" min="20" max="100" step="10" value="50">
            </div>
            
            <div class="param-control">
                <div class="param-header">
                    <span class="param-label">감염률 (β)</span>
                    <span class="param-value" id="infection-rate-value">1.0</span>
                </div>
                <input type="range" id="infection-rate" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>
            
            <div class="param-control">
                <div class="param-header">
                    <span class="param-label">회복 기간 (프레임)</span>
                    <span class="param-value" id="recovery-period-value">150</span>
                </div>
                <input type="range" id="recovery-period" min="40" max="300" step="10" value="150">
            </div>
            
            <div class="param-control">
                <div class="param-header">
                    <span class="param-label">사회적 거리두기 (px)</span>
                    <span class="param-value" id="social-distance-value">30</span>
                </div>
                <input type="range" id="social-distance" min="20" max="60" step="5" value="30">
            </div>
            
            <div class="param-control">
                <div class="param-header">
                    <span class="param-label">이동 속도</span>
                    <span class="param-value" id="movement-speed-value">1.5</span>
                </div>
                <input type="range" id="movement-speed" min="0.5" max="3.0" step="0.1" value="1.5">
            </div>
            
            <div class="button-row">
                <button class="btn btn-primary" id="start-btn">시작</button>
                <button class="btn btn-secondary" id="reset-btn">초기화</button>
            </div>
            
            <div class="guide-content" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <h4 style="margin-top: 0; color: #ffa500; font-size: 1rem;">📖 SIR 모델 이해하기</h4>
                <p>SIR 모델은 <span class="highlight">전염병의 확산</span>을 수학적으로 표현한 모델로, 인구를 세 그룹으로 나눕니다:</p>
                <ul>
                    <li><span class="highlight">S (감수성자)</span>: 아직 감염되지 않았지만 감염될 가능성이 있는 사람</li>
                    <li><span class="highlight">I (감염자)</span>: 현재 감염된 사람으로 다른 사람을 감염시킬 수 있음</li>
                    <li><span class="highlight">R (회복자)</span>: 감염으로부터 회복되어 면역이 생긴 사람</li>
                </ul>
                <p>이 시뮬레이션에서 제어할 수 있는 주요 매개변수:</p>
                <ul>
                    <li><span class="highlight">감염률(β)</span>: 접촉 시 감염 확률</li>
                    <li><span class="highlight">회복 기간</span>: 감염자가 회복되는 데 걸리는 시간</li>
                    <li><span class="highlight">사회적 거리두기</span>: 감염 가능한 거리 (거리가 클수록 감염 확률 높음)</li>
                </ul>
                <p>이 모델을 통해 사회적 거리두기, 백신 접종 등의 방역 정책이 전염병 확산에 미치는 영향을 이해할 수 있습니다.</p>
            </div>
        </div>
    </div>
    
    <!-- 통계 패널 (우상단) -->
    <div class="floating-card stats-card draggable" id="stats-card">
        <div class="card-header">
            <h3><span class="icon">📊</span> 실시간 통계</h3>
            <button class="card-toggle" id="toggle-stats">−</button>
        </div>
        <div class="card-content" id="stats-content">
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="s-count" style="color: #0ea5e9;">45</div>
                    <div class="stat-label">감수성자 (S)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="i-count" style="color: #ef4444;">5</div>
                    <div class="stat-label">감염자 (I)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="r-count" style="color: #22c55e;">0</div>
                    <div class="stat-label">회복자 (R)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="time-count" style="color: #ffa500;">0</div>
                    <div class="stat-label">시간 (프레임)</div>
                </div>
            </div>
        </div>
    </div>

<script type="text/javascript">

// ========== 글로벌 설정 및 상수 ==========
const CONFIG = {
    // 에이전트 관련
    agent: {
        size: 40,                    // 에이전트 크기 (px) - 50에서 40으로 축소
        radius: 20,                  // 에이전트 반경 (px) - 25에서 20으로 축소
        initialVelocity: 1.5,        // 초기 속도 범위 - 2에서 1.5로 축소
        colors: {
            susceptible: "#0ea5e9",  // 감수성자 색상
            infected: "#ef4444",     // 감염자 색상
            recovered: "#22c55e"     // 회복자 색상
        }
    },

    // 시뮬레이션 관련
    simulation: {
        initialInfectedRatio: 0.1,   // 초기 감염자 비율
        frameDelay: 50,              // 프레임 지연 (ms)
        timeScale: 3                 // 시간 스케일 (n프레임당 1 카운트)
    },

    // 물리 시스템 관련
    physics: {
        borderMargin: 30,            // 화면 경계 여백 (px)
        bounceDamping: 0.9,          // 충돌시 속도 감쇠 계수
        velocityJitter: 0.2,         // 속도 변동 정도 - 0.3에서 0.2로 축소
        cardAvoidForce: 0.3          // 카드 회피 힘 - 0.5에서 0.3으로 축소
    },

    // UI 관련
    ui: {
        cardHeight: 400,             // 카드 높이 추정값 (px)
        controlCardWidth: 320,       // 컨트롤 카드 너비 (px)
        statsCardWidth: 280          // 통계 카드 너비 (px)
    },

    // 가상 경계 마진(에이전트 활동 영역 오프셋)
    virtualMargin: {
        left: 250,
        top: 200,
        right: 250,
        bottom: 200
    }
};

// 이전 코드와의 호환성 유지를 위한 상수
const AGENT_SIZE = CONFIG.agent.size;
const AGENT_RADIUS = CONFIG.agent.radius;

// ========== 물리 시스템 클래스 ==========
class PhysicsSystem {
    constructor(simulation) {
        this.sim = simulation;
        this.config = simulation.config;
        this.cards = null; // UI 카드 캐시
    }
    
    /**
     * UI 카드 요소 캐시 설정
     * @param {HTMLElement[]} cards - UI 카드 요소 배열
     */
    setCards(cards) {
        this.cards = cards;
    }
    
    /**
     * 모든 에이전트의 물리 업데이트
     * @param {Array} agents - 에이전트 배열
     * @param {number} movementSpeed - 최대 이동 속도
     */
    updateAll(agents, movementSpeed) {
        agents.forEach(agent => {
            // 1. 랜덤 이동 적용
            this.applyRandomMovement(agent);
            
            // 2. 속도 제한 적용
            this.limitVelocity(agent, movementSpeed);
            
            // 3. 위치 업데이트
            this.updatePosition(agent);
            
            // 4. 경계 충돌 처리
            this.handleBoundaryCollision(agent);
        });
    }
    
    /**
     * 두 에이전트 간의 거리 계산 
     * @param {Object} agent1 - 첫 번째 에이전트
     * @param {Object} agent2 - 두 번째 에이전트
     * @returns {number} - 두 에이전트 중심 간 거리
     */
    calculateDistance(agent1, agent2) {
        const radius = this.config.agent.radius;
        const dx = (agent1.x + radius) - (agent2.x + radius);
        const dy = (agent1.y + radius) - (agent2.y + radius);
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * 랜덤 이동 요소 적용
     * @param {Object} agent - 에이전트 객체
     */
    applyRandomMovement(agent) {
        const jitter = this.config.physics.velocityJitter;
        agent.vx += (Math.random() - 0.5) * jitter;
        agent.vy += (Math.random() - 0.5) * jitter;
    }
    
    /**
     * 에이전트 속도 제한
     * @param {Object} agent - 에이전트 객체 
     * @param {number} maxSpeed - 최대 속도
     */
    limitVelocity(agent, maxSpeed) {
        const speed = Math.sqrt(agent.vx * agent.vx + agent.vy * agent.vy);
        if (speed > maxSpeed) {
            agent.vx = (agent.vx / speed) * maxSpeed;
            agent.vy = (agent.vy / speed) * maxSpeed;
        }
    }
    
    /**
     * 위치 업데이트
     * @param {Object} agent - 에이전트 객체
     */
    updatePosition(agent) {
        agent.x += agent.vx;
        agent.y += agent.vy;
    }
    
    /**
     * 경계 충돌 처리
     * @param {Object} agent - 에이전트 객체
     */
    handleBoundaryCollision(agent) {
        const { bounceDamping } = this.config.physics;
        const { size } = this.config.agent;
        const containerWidth = this.sim.containerWidth;
        const containerHeight = this.sim.containerHeight;
        const margin = this.config.virtualMargin;
        // 가상 경계 계산
        const minX = margin.left;
        const minY = margin.top;
        const maxX = containerWidth - size - margin.right;
        const maxY = containerHeight - size - margin.bottom;
        // 좌우 경계 충돌 검사 및 처리
        if (agent.x < minX) {
            agent.x = minX;
            agent.vx = Math.abs(agent.vx) * bounceDamping;
        } else if (agent.x > maxX) {
            agent.x = maxX;
            agent.vx = -Math.abs(agent.vx) * bounceDamping;
        }
        // 상하 경계 충돌 검사 및 처리
        if (agent.y < minY) {
            agent.y = minY;
            agent.vy = Math.abs(agent.vy) * bounceDamping;
        } else if (agent.y > maxY) {
            agent.y = maxY;
            agent.vy = -Math.abs(agent.vy) * bounceDamping;
        }
        // 최종 안전장치: 절대로 경계를 벗어날 수 없도록 보장
        agent.x = Math.max(minX, Math.min(maxX, agent.x));
        agent.y = Math.max(minY, Math.min(maxY, agent.y));
        // 시각 요소 위치 강제 업데이트
        const element = document.getElementById(`agent-${agent.id}`);
        if (element) {
            element.style.left = agent.x + 'px';
            element.style.top = agent.y + 'px';
        }
    }
    
    /**
     * UI 카드 영역 회피 처리
     * @param {Object} agent - 에이전트 객체
     * @param {HTMLElement[]} cards - 카드 요소 배열
     */
    avoidCards(agent, cards) {
        const { radius } = this.config.agent;
        const { cardAvoidForce } = this.config.physics;
        const buffer = this.config.physics.borderMargin;
        
        for (const card of cards) {
            if (!card) continue;
            
            const cardRect = card.getBoundingClientRect();
            
            // 에이전트 중심
            const agentCenterX = agent.x + radius;
            const agentCenterY = agent.y + radius;
            
            // 카드 영역 확장 (버퍼 포함)
            if (agentCenterX > cardRect.left - buffer && 
                agentCenterX < cardRect.right + buffer &&
                agentCenterY > cardRect.top - buffer && 
                agentCenterY < cardRect.bottom + buffer) {
                
                // 카드 중심
                const cardCenterX = cardRect.left + cardRect.width / 2;
                const cardCenterY = cardRect.top + cardRect.height / 2;
                
                // 에이전트와 카드 사이의 방향 벡터
                const dx = agentCenterX - cardCenterX;
                const dy = agentCenterY - cardCenterY;
                
                // 방향 벡터 정규화
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    // 카드 회피 힘 적용 (거리에 반비례)
                    const forceFactor = Math.min(1.0, buffer / Math.max(10, distance));
                    agent.vx += (dx / distance) * cardAvoidForce * forceFactor;
                    agent.vy += (dy / distance) * cardAvoidForce * forceFactor;
                }
            }
        }
    }
}

// ========== 개별 에이전트 Vega 스펙 ==========
function createAgentSpec(agentId, initialStatus) {
    return {
        "$schema": "https://vega.github.io/schema/vega/v5.json",
        "width": AGENT_SIZE,
        "height": AGENT_SIZE,
        "padding": 0,
        "autosize": "none",
        "background": "transparent",

        "signals": [
            { "name": "status", "value": initialStatus },
            { "name": "infection_timer", "value": 0 },
            { "name": "recovery_timer", "value": 0 }
        ],

        "data": [
            {
                "name": "agent_data",
                "values": [{"id": agentId}]
            }
        ],

        "scales": [
            {
                "name": "color_scale",
                "type": "ordinal",
                "domain": ["S", "I", "R"],
                "range": [CONFIG.agent.colors.susceptible, CONFIG.agent.colors.infected, CONFIG.agent.colors.recovered]
            },
            {
                "name": "size_scale",
                "type": "ordinal",
                "domain": ["S", "I", "R"],
                "range": [400, 500, 350]
            }
        ],

        "marks": [
            // 감염 범위 표시 (감염자만)
            {
                "name": "infection_range",
                "type": "symbol",
                "encode": {
                    "update": {
                        "x": {"value": AGENT_RADIUS},
                        "y": {"value": AGENT_RADIUS},
                        "size": [
                            {
                                "test": "status === 'I'",
                                "signal": "pow(datum.social_distance || 30, 2) * 3.14"
                            },
                            {"value": 0}
                        ],
                        "fill": {"value": "rgba(239, 68, 68, 0.15)"},
                        "stroke": {"value": "rgba(239, 68, 68, 0.3)"},
                        "strokeWidth": {"value": 1},
                        "opacity": [
                            {
                                "test": "status === 'I'",
                                "value": 0.6
                            },
                            {"value": 0}
                        ]
                    }
                }
            },
            // 에이전트 몸체
            {
                "name": "agent_body",
                "type": "symbol",
                "from": {"data": "agent_data"},
                "encode": {
                    "update": {
                        "x": {"value": AGENT_RADIUS},
                        "y": {"value": AGENT_RADIUS},
                        "size": {"scale": "size_scale", "signal": "status"},
                        "fill": {"scale": "color_scale", "signal": "status"},
                        "stroke": {"value": "rgba(255, 255, 255, 0.8)"},
                        "strokeWidth": {"value": 2},
                        "opacity": {"value": 0.9}
                    }
                }
            }
        ]
    };
}

// ========== SIR 시뮬레이션 클래스 ==========
class SIRSimulationV2 {
    constructor() {
        // 상태 및 에이전트 관리
        this.agents = [];
        this.agentViews = [];
        this.agentElements = [];
        
        // 애니메이션 상태
        this.isRunning = false;
        this.animationId = null;
        this.frameCount = 0;
        this.animationFrame = 0;
        
        // 컨테이너 크기
        this.containerWidth = window.innerWidth;
        this.containerHeight = window.innerHeight;
        
        // 설정 참조
        this.config = CONFIG;
        
        // 서브시스템 초기화
        this.physics = new PhysicsSystem(this);
        
        // 시뮬레이션 초기화
        this.init();
    }
    
    async init() {
        // 디버깅: 컨테이너 크기 확인
        this.debugContainerSize();
        this.setupEventListeners();
        await this.createAgents();
        this.updateStats();
        this.setupCardToggles();
    }
    
    // 컨테이너 크기 디버깅 메서드
    debugContainerSize() {
        const container = document.getElementById('simulation-area');
        const rect = container.getBoundingClientRect();
        const margin = this.config.virtualMargin;
        
        console.log('=== 컨테이너 크기 디버깅 ===');
        console.log('실제 컨테이너 크기:', rect.width, 'x', rect.height);
        console.log('내부 containerWidth/Height:', this.containerWidth, 'x', this.containerHeight);
        console.log('가상 마진:', margin);
        console.log('가상 캔버스 크기:', 
            this.containerWidth - margin.left - margin.right, 'x',
            this.containerHeight - margin.top - margin.bottom);
        console.log('에이전트 생성 가능 영역:', 
            (this.containerWidth - CONFIG.agent.size - margin.left - margin.right), 'x',
            (this.containerHeight - CONFIG.agent.size - margin.top - margin.bottom));
        console.log('========================');
    }
    
    async createAgents() {
        const container = document.getElementById('simulation-area');
        container.innerHTML = '';
        
        this.agents = [];
        this.agentViews = [];
        this.agentElements = [];
        this.frameCount = 0;
        this.animationFrame = 0;
        
        const population = parseInt(document.getElementById('population').value);
        const centerX = this.containerWidth / 2;
        const centerY = this.containerHeight / 2;
        
        // 감염자 비율 설정
        const infectionRatio = this.config.simulation.initialInfectedRatio;
        const initialInfectedCount = Math.max(1, Math.round(population * infectionRatio));
        
        // 모든 에이전트의 상태를 미리 결정 (무작위로 섞기 위해)
        const statuses = [];
        for (let i = 0; i < population; i++) {
            statuses.push(i < initialInfectedCount ? 'I' : 'S');
        }
        
        // Fisher-Yates 알고리즘으로 상태 배열 섞기
        for (let i = statuses.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [statuses[i], statuses[j]] = [statuses[j], statuses[i]];
        }
        
        for (let i = 0; i < population; i++) {
            let x, y;
            const status = statuses[i];
            // 가상 마진 적용
            const margin = this.config.virtualMargin;
            x = margin.left + Math.random() * (this.containerWidth - AGENT_SIZE - margin.left - margin.right);
            y = margin.top + Math.random() * (this.containerHeight - AGENT_SIZE - margin.top - margin.bottom);
            // UI 영역을 피하기 위한 추가 로직
            // 왼쪽 상단 (컨트롤 카드)과 오른쪽 상단(통계 카드) 영역 피하기
            const { controlCardWidth, statsCardWidth, cardHeight } = this.config.ui;
            
            if (y < cardHeight + margin.top) {
                if (x < controlCardWidth + margin.left) {
                    // 왼쪽 상단 영역이면 아래로 이동
                    y = Math.max(y + cardHeight, margin.top);
                } else if (x > this.containerWidth - statsCardWidth - margin.right) {
                    // 오른쪽 상단 영역이면 아래로 이동
                    y = Math.max(y + cardHeight, margin.top);
                }
            }
            
            // 가상 마진 기반 경계 체크 (최종 안전장치)
            const maxX = this.containerWidth - AGENT_SIZE - margin.right;
            const maxY = this.containerHeight - AGENT_SIZE - margin.bottom;
            x = Math.max(margin.left, Math.min(maxX, x));
            y = Math.max(margin.top, Math.min(maxY, y));
            
            // 에이전트 데이터
            const agent = {
                id: i,
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * this.config.agent.initialVelocity,
                vy: (Math.random() - 0.5) * this.config.agent.initialVelocity,
                status: status,
                infection_timer: status === 'I' ? 1 : 0,
                recovery_timer: 0
            };
            
            // HTML 요소 생성
            const agentElement = document.createElement('div');
            agentElement.className = 'agent';
            agentElement.style.left = `${x}px`;
            agentElement.style.top = `${y}px`;
            agentElement.id = `agent-${i}`;
            container.appendChild(agentElement);
            
            // Vega 스펙 생성 및 임베드
            const spec = createAgentSpec(i, status);
            const result = await vegaEmbed(`#agent-${i}`, spec, {actions: false});
            
            this.agents.push(agent);
            this.agentViews.push(result.view);
            this.agentElements.push(agentElement);
        }
    }
    
    setupEventListeners() {
        // 시작 버튼
        document.getElementById('start-btn').addEventListener('click', () => {
            if (this.isRunning) {
                this.pause();
            } else {
                this.start();
            }
        });
        
        // 초기화 버튼
        document.getElementById('reset-btn').addEventListener('click', () => {
            this.reset();
        });
        
        // 매개변수 슬라이더들
        const sliders = [
            'population', 'infection-rate', 'recovery-period', 
            'social-distance', 'movement-speed'
        ];
        
        sliders.forEach(sliderId => {
            const slider = document.getElementById(sliderId);
            const valueSpan = document.getElementById(`${sliderId}-value`);
            
            slider.addEventListener('input', (e) => {
                valueSpan.textContent = e.target.value;
                
                // 인구수 변경시 에이전트 재생성
                if (sliderId === 'population' && !this.isRunning) {
                    this.reset();
                }
                
                // 사회적 거리두기 변경 시 Vega 뷰에 알림
                if (sliderId === 'social-distance') {
                    this.updateSocialDistance();
                }
            });
        });
        
        // 창 크기 변경 대응
        window.addEventListener('resize', () => {
            this.updateContainerSize();
        });
    }
    
    // 카드 접기/펼치기 토글 기능
    setupCardToggles() {
        const toggles = [
            { toggleId: 'toggle-controls', contentId: 'controls-content' },
            { toggleId: 'toggle-stats', contentId: 'stats-content' }
        ];
        
        toggles.forEach(({toggleId, contentId}) => {
            const toggleBtn = document.getElementById(toggleId);
            const content = document.getElementById(contentId);
            
            toggleBtn.addEventListener('click', () => {
                if (content.classList.contains('collapsed')) {
                    content.classList.remove('collapsed');
                    toggleBtn.textContent = '−';
                } else {
                    content.classList.add('collapsed');
                    toggleBtn.textContent = '+';
                }
            });
        });
    }
    
    // 사회적 거리두기 변경 시 Vega 뷰에 반영
    updateSocialDistance() {
        const socialDistance = parseInt(document.getElementById('social-distance').value);
        
        this.agents.forEach((agent, i) => {
            if (agent.status === 'I') {
                // 감염자의 감염 범위 업데이트
                this.agentViews[i].data('agent_data', [
                    {id: agent.id, social_distance: socialDistance}
                ]).runAsync();
            }
        });
    }
    
    updateContainerSize() {
        this.containerWidth = window.innerWidth;
        this.containerHeight = window.innerHeight;
    }
    
    start() {
        this.isRunning = true;
        document.getElementById('start-btn').textContent = '일시정지';
        document.getElementById('start-btn').classList.remove('btn-primary');
        document.getElementById('start-btn').classList.add('btn-secondary');
        
        this.animate();
    }
    
    pause() {
        this.isRunning = false;
        document.getElementById('start-btn').textContent = '시작';
        document.getElementById('start-btn').classList.remove('btn-secondary');
        document.getElementById('start-btn').classList.add('btn-primary');
        
        if (this.animationId) {
            clearTimeout(this.animationId); // setTimeout 취소
            this.animationId = null;
        }
    }
    
    async reset() {
        this.pause();
        this.animationFrame = 0;
        await this.createAgents();
        this.updateStats();
    }
    
    animate() {
        if (!this.isRunning) return;
        
        // 시간 스케일에 따라 카운팅
        if (this.animationFrame % this.config.simulation.timeScale === 0) {
            this.frameCount++;
        }
        this.animationFrame = (this.animationFrame || 0) + 1;
        
        // 시뮬레이션 및 통계 업데이트
        this.updateSimulation();
        this.updateStats();
        
        // 설정된 지연 시간으로 애니메이션 속도 제어
        this.animationId = setTimeout(() => {
            requestAnimationFrame(() => this.animate());
        }, this.config.simulation.frameDelay);
    }
    
    updateSimulation() {
        // UI 파라미터 읽기
        const movementSpeed = parseFloat(document.getElementById('movement-speed').value);
        const socialDistance = parseInt(document.getElementById('social-distance').value);
        const infectionRate = parseFloat(document.getElementById('infection-rate').value);
        const recoveryPeriod = parseInt(document.getElementById('recovery-period').value);
        
        // UI 카드 요소 수집 및 물리 시스템에 설정
        const cards = [
            document.getElementById('controls-card'),
            document.getElementById('stats-card'),
            document.getElementById('guide-card')
        ];
        this.physics.setCards(cards);
        
        // ===== 1. 물리 처리: 이동, 경계 충돌 =====
        // 모든 에이전트의 기본 물리 업데이트 (이동, 속도 제한, 경계 충돌)
        this.physics.updateAll(this.agents, movementSpeed);
        
        // 각 에이전트에 카드 회피 적용 및 UI 업데이트
        this.agents.forEach((agent, i) => {
            // 카드 회피 처리
            this.physics.avoidCards(agent, cards);
            
            // HTML 요소 위치 업데이트
            this.agentElements[i].style.left = `${agent.x}px`;
            this.agentElements[i].style.top = `${agent.y}px`;
        });
        
        // ===== 2. 감염 상태 처리 =====
        this.agents.forEach((agent, i) => {
            // SIR 모델 상태 변화 처리 
            this.updateAgentStatus(agent, socialDistance, infectionRate, recoveryPeriod);
            
            // Vega 뷰 업데이트
            this.agentViews[i].signal('status', agent.status);
            this.agentViews[i].signal('infection_timer', agent.infection_timer);
            this.agentViews[i].signal('recovery_timer', agent.recovery_timer);
            this.agentViews[i].runAsync();
        });
    }
    
    /**
     * 단일 에이전트의 SIR 상태 업데이트
     * @param {Object} agent - 업데이트할 에이전트
     * @param {number} socialDistance - 사회적 거리두기 범위
     * @param {number} infectionRate - 감염 확률 (0-1)
     * @param {number} recoveryPeriod - 회복 기간 (프레임 단위)
     */
    updateAgentStatus(agent, socialDistance, infectionRate, recoveryPeriod) {
        if (agent.status === 'S') {
            // 감수성자 - 주변 감염자 확인
            this.checkForInfection(agent, socialDistance, infectionRate);
        } else if (agent.status === 'I') {
            // 감염자 - 회복 타이머 진행
            agent.infection_timer++;
            if (agent.infection_timer >= recoveryPeriod) {
                agent.status = 'R';
                agent.recovery_timer = 1;
            }
        } else if (agent.status === 'R') {
            // 회복자 - 회복 타이머 증가
            agent.recovery_timer++;
        }
    }
    
    /**
     * 감염 가능성 확인
     * @param {Object} susceptibleAgent - 감수성자 에이전트
     * @param {number} socialDistance - 사회적 거리두기 범위
     * @param {number} infectionRate - 감염 확률 (0-1)
     */
    checkForInfection(susceptibleAgent, socialDistance, infectionRate) {
        for (let other of this.agents) {
            if (other.status === 'I') {
                // 중심점 간의 거리 계산
                const radius = this.config.agent.radius;
                const dx = (susceptibleAgent.x + radius) - (other.x + radius);
                const dy = (susceptibleAgent.y + radius) - (other.y + radius);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 감염 로직
                if (distance < socialDistance && Math.random() < infectionRate / 10) {
                    susceptibleAgent.status = 'I';
                    susceptibleAgent.infection_timer = 1;
                    break;
                }
            }
        }
    }
    
    updateStats() {
        const counts = { S: 0, I: 0, R: 0 };
        this.agents.forEach(agent => {
            counts[agent.status]++;
        });
        
        document.getElementById('s-count').textContent = counts.S;
        document.getElementById('i-count').textContent = counts.I;
        document.getElementById('r-count').textContent = counts.R;
        document.getElementById('time-count').textContent = this.frameCount;
    }
}

// 드래그 가능한 모달 카드 구현
function makeDraggable() {
    const draggableElements = document.querySelectorAll('.draggable');
    
    draggableElements.forEach(element => {
        const header = element.querySelector('.card-header');
        let isDragging = false;
        let offsetX, offsetY;
        
        // 드래그 시작
        header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - element.getBoundingClientRect().left;
            offsetY = e.clientY - element.getBoundingClientRect().top;
            element.style.zIndex = 1001; // 현재 드래그 중인 요소를 최상위로
            
            // 드래그 중 커서 스타일 추가
            header.style.cursor = 'grabbing';
        });
        
        // 드래그 이동
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            // 새 위치 계산
            let newLeft = e.clientX - offsetX;
            let newTop = e.clientY - offsetY;
            
            // 화면 밖으로 나가지 않도록 제한
            newLeft = Math.max(0, Math.min(window.innerWidth - element.offsetWidth, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - element.offsetHeight, newTop));
            
            // 위치 적용
            element.style.left = newLeft + 'px';
            element.style.top = newTop + 'px';
            element.style.right = 'auto'; // right 속성 제거
            element.style.bottom = 'auto'; // bottom 속성 제거
        });
        
        // 드래그 종료
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                element.style.zIndex = 1000; // 원래 z-index로 복원
                header.style.cursor = 'move'; // 커서 스타일 복원
            }
        });
        
        // 터치 이벤트 지원 (모바일)
        header.addEventListener('touchstart', (e) => {
            isDragging = true;
            const touch = e.touches[0];
            offsetX = touch.clientX - element.getBoundingClientRect().left;
            offsetY = touch.clientY - element.getBoundingClientRect().top;
            element.style.zIndex = 1001;
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            e.preventDefault(); // 스크롤 방지
            
            const touch = e.touches[0];
            let newLeft = touch.clientX - offsetX;
            let newTop = touch.clientY - offsetY;
            
            newLeft = Math.max(0, Math.min(window.innerWidth - element.offsetWidth, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - element.offsetHeight, newTop));
            
            element.style.left = newLeft + 'px';
            element.style.top = newTop + 'px';
            element.style.right = 'auto';
            element.style.bottom = 'auto';
        });
        
        document.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                element.style.zIndex = 1000;
            }
        });
    });
}

// 시뮬레이션 시작
window.addEventListener('load', () => {
    if (typeof vega !== 'undefined' && typeof vegaEmbed !== 'undefined') {
        new SIRSimulationV2();
        makeDraggable(); // 드래그 기능 활성화
        // 디버그용 경계선 추가
        const simArea = document.getElementById('simulation-area');
        if (simArea) {
            const border = document.createElement('div');
            border.style.position = 'absolute';
            border.style.left = '0';
            border.style.top = '0';
            border.style.width = '100%';
            border.style.height = '100%';
            border.style.border = '2px dashed #ff4444';
            border.style.boxSizing = 'border-box';
            border.style.pointerEvents = 'none';
            border.style.zIndex = '10000';
            simArea.appendChild(border);
        }
    } else {
        console.error('Vega 라이브러리 로딩 실패');
        document.body.innerHTML = '<h3 style="color:red; text-align:center; padding-top: 50px;">Vega 라이브러리를 로드할 수 없습니다. 페이지를 새로고침해주세요.</h3>';
    }
});

</script>
</body>
</html>
