<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>벡터장 시각화 - Animation Lab</title>
    <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@5"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0F4C75 0%, #3282B8 50%, #0F3460 100%);
            color: white;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at 20% 80%, rgba(255,255,255,0.03) 0%, rgba(0,0,0,0.4) 100%);
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #vegaVectorArrows {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #vegaVectorField {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            pointer-events: none;
            background: rgba(0,0,0,0.8);
            border-radius: 12px;
            padding: 15px;
            width: 280px;
            height: 220px;
        }

        #vegaFieldStats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 2;
            pointer-events: none;
            background: rgba(0,0,0,0.8);
            border-radius: 12px;
            padding: 15px;
            width: 280px;
            height: 160px;
        }

        .control-panel {
            width: 380px;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 20px;
            overflow-y: auto;
        }

        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .back-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }

        .experiment-title {
            font-size: 1.4rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 8px;
            color: #3282B8;
        }

        .experiment-desc {
            font-size: 0.9rem;
            opacity: 0.8;
            text-align: center;
            margin-bottom: 20px;
        }

        .field-selector {
            margin-bottom: 25px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .field-selector h3 {
            margin-bottom: 15px;
            color: #3282B8;
            font-size: 1.1rem;
        }

        .field-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .field-btn {
            background: rgba(50, 130, 184, 0.2);
            border: 1px solid rgba(50, 130, 184, 0.4);
            color: white;
            padding: 10px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            text-align: center;
        }

        .field-btn:hover {
            background: rgba(50, 130, 184, 0.4);
            transform: translateY(-1px);
        }

        .field-btn.active {
            background: rgba(50, 130, 184, 0.6);
            border-color: #3282B8;
        }

        .control-group {
            margin-bottom: 25px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #3282B8;
            font-size: 1.1rem;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3282B8;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .value-display {
            background: rgba(255,255,255,0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            min-width: 50px;
            text-align: center;
        }

        .animation-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .anim-btn {
            flex: 1;
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid rgba(76, 175, 80, 0.5);
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .anim-btn:hover {
            background: rgba(76, 175, 80, 0.5);
            transform: translateY(-1px);
        }

        .anim-btn.active {
            background: rgba(76, 175, 80, 0.7);
        }

        .learning-section {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .learning-section h3 {
            margin-bottom: 15px;
            color: #FF6B6B;
            font-size: 1.1rem;
        }

        .concept-item {
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            border-left: 3px solid #FF6B6B;
        }

        .concept-item h4 {
            font-size: 0.9rem;
            margin-bottom: 4px;
            color: #FFB74D;
        }

        .concept-item p {
            font-size: 0.8rem;
            opacity: 0.8;
            line-height: 1.3;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
                max-height: 40vh;
                order: -1;
            }
            
            .canvas-area {
                flex: 1;
                min-height: 60vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-area">
            <canvas id="mainCanvas"></canvas>
            <div id="vegaVectorArrows"></div>
            <div id="vegaVectorField"></div>
            <div id="vegaFieldStats"></div>
        </div>
        
        <div class="control-panel">
            <div class="nav-header">
                <a href="../../index.html" class="back-btn">← 돌아가기</a>
            </div>
            
            <div class="experiment-title">📐 벡터장 시각화</div>
            <div class="experiment-desc">그래디언트, 발산, 회전 필드의 흐름을 직관적으로 시각화</div>
            
            <div class="field-selector">
                <h3>🎯 벡터장 유형</h3>
                <div class="field-buttons">
                    <button class="field-btn active" data-field="gradient">그래디언트</button>
                    <button class="field-btn" data-field="divergence">발산</button>
                    <button class="field-btn" data-field="curl">회전</button>
                    <button class="field-btn" data-field="uniform">균등</button>
                    <button class="field-btn" data-field="saddle">새들점</button>
                    <button class="field-btn" data-field="wave">파동</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>📊 실시간 분석</h3>
                <div class="control-item">
                    <label>현재 필드 정보</label>
                    <div id="fieldInfo" class="value-display" style="width: 100%; margin-top: 5px; padding: 8px; background: rgba(255,255,255,0.1)">
                        분석 중...
                    </div>
                </div>
                <div class="control-item">
                    <label>활성 입자 수</label>
                    <div class="slider-container">
                        <div class="value-display" id="activeParticles" style="background: rgba(76, 175, 80, 0.3)">0</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>� 흐름 시각화</h3>
                <div class="control-item">
                    <label>강도 (Strength)</label>
                    <div class="slider-container">
                        <input type="range" id="strength" min="0.1" max="3.0" step="0.1" value="1.0">
                        <div class="value-display" id="strengthValue">1.0</div>
                    </div>
                </div>
                <div class="control-item">
                    <label>입자 수</label>
                    <div class="slider-container">
                        <input type="range" id="particleCount" min="50" max="500" step="25" value="200">
                        <div class="value-display" id="particleCountValue">200</div>
                    </div>
                </div>
                <div class="control-item">
                    <label>흐름 속도</label>
                    <div class="slider-container">
                        <input type="range" id="flowSpeed" min="0.1" max="2.0" step="0.1" value="0.1">
                        <div class="value-display" id="flowSpeedValue">0.1</div>
                    </div>
                </div>
                <div class="animation-controls">
                    <button class="anim-btn" id="playPause">⏸️ 일시정지</button>
                    <button class="anim-btn" id="reset">🔄 초기화</button>
                </div>
            </div>
            
            <div class="learning-section">
                <h3>📚 학습 가이드</h3>
                <div class="concept-item">
                    <h4>그래디언트 (Gradient)</h4>
                    <p>스칼라 함수 f(x,y)의 그래디언트 ∇f는 가장 가파른 증가 방향을 나타냅니다. 물리학에서는 중력장이나 전기장에서 나타납니다.</p>
                </div>
                <div class="concept-item">
                    <h4>발산 (Divergence)</h4>
                    <p>div F = ∂Fx/∂x + ∂Fy/∂y로 계산되며, 양수면 소스, 음수면 싱크를 의미합니다. 유체역학에서 압축성을 나타냅니다.</p>
                </div>
                <div class="concept-item">
                    <h4>회전 (Curl)</h4>
                    <p>2D에서 curl F = ∂Fy/∂x - ∂Fx/∂y로 계산되며, 벡터장의 회전 정도를 나타냅니다. 전자기학에서 중요한 개념입니다.</p>
                </div>
                <div class="concept-item">
                    <h4>새들점 (Saddle Point)</h4>
                    <p>한 방향으로는 수렴하고 다른 방향으로는 발산하는 불안정한 평형점입니다. 역학계에서 중요한 특이점입니다.</p>
                </div>
                <div class="concept-item">
                    <h4>유선 (Streamlines)</h4>
                    <p>벡터장의 흐름을 따라 그려지는 곡선으로, 입자의 궤적을 보여줍니다. 미분방정식 dx/dt = F(x,y)의 해입니다.</p>
                </div>
                <div class="concept-item">
                    <h4>💡 실험 팁</h4>
                    <p>• 서로 다른 필드 간 전환하여 비교해보세요<br>
                    • 강도를 변화시켜 스케일링 효과를 관찰하세요<br>
                    • 입자의 궤적을 통해 필드의 성질을 파악하세요</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 설정 상수들
        const CONFIG = {
            VECTOR_DENSITY: 20,
            ARROW_SHAFT_LENGTH: 15,
            PARTICLE_TRAIL_MAX: 15,
            PARTICLE_LIFE_MIN: 500,
            PARTICLE_LIFE_MAX: 1500,
            CANVAS_UPDATE_RATE: 60, // FPS
            VEGA_UPDATE_RATE: 60,   // 60프레임마다 Vega 업데이트
            INFO_UPDATE_RATE: 30,   // 30프레임마다 정보 업데이트
            COLORS: {
                ARROW_SHAFT: 'rgba(50, 130, 184, 0.5)',
                ARROW_HEAD: 'rgba(50, 130, 184, 0.8)',
                PARTICLE_BASE: 200,
                PARTICLE_RANGE: 160
            }
        };

        // 벡터 필드 계산 클래스
        class VectorFieldMath {
            static getVectorAt(x, y, centerX, centerY, fieldType, strength, time) {
                const nx = (x - centerX) / 100;
                const ny = (y - centerY) / 100;
                const t = time * 0.02;
                
                const fieldFunctions = {
                    gradient: () => this.gradientField(nx, ny, strength),
                    divergence: () => this.divergenceField(nx, ny, strength),
                    curl: () => this.curlField(nx, ny, strength),
                    uniform: () => this.uniformField(strength),
                    saddle: () => this.saddleField(nx, ny, strength),
                    wave: () => this.waveField(nx, ny, t, strength)
                };
                
                return fieldFunctions[fieldType]?.() || { x: 0, y: 0 };
            }
            
            static gradientField(nx, ny, strength) {
                const dist = Math.sqrt(nx * nx + ny * ny);
                if (dist === 0) return { x: 0, y: 0 };
                return {
                    x: (nx / dist) * strength,
                    y: (ny / dist) * strength
                };
            }
            
            static divergenceField(nx, ny, strength) {
                return { x: nx * strength, y: ny * strength };
            }
            
            static curlField(nx, ny, strength) {
                return { x: -ny * strength, y: nx * strength };
            }
            
            static uniformField(strength) {
                return { x: strength, y: 0 };
            }
            
            static saddleField(nx, ny, strength) {
                return { x: nx * strength, y: -ny * strength };
            }
            
            static waveField(nx, ny, t, strength) {
                return {
                    x: Math.sin(ny * 2 + t) * strength,
                    y: Math.cos(nx * 2 + t) * strength
                };
            }
        }

        // 입자 시스템 클래스
        class ParticleSystem {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.particles = [];
            }
            
            initParticles(count) {
                this.particles = [];
                for (let i = 0; i < count; i++) {
                    this.particles.push(this.createParticle());
                }
            }
            
            createParticle() {
                return {
                    x: Math.random() * this.width,
                    y: Math.random() * this.height,
                    trail: [],
                    color: `hsl(${CONFIG.COLORS.PARTICLE_BASE + Math.random() * CONFIG.COLORS.PARTICLE_RANGE}, 70%, 60%)`,
                    life: Math.random() * (CONFIG.PARTICLE_LIFE_MAX - CONFIG.PARTICLE_LIFE_MIN) + CONFIG.PARTICLE_LIFE_MIN
                };
            }
            
            updateParticles(getVectorAt, flowSpeed, isAnimating) {
                if (!isAnimating) return;
                
                this.particles.forEach(particle => {
                    const vector = getVectorAt(particle.x, particle.y);
                    
                    // 궤적 저장
                    particle.trail.push({ x: particle.x, y: particle.y });
                    if (particle.trail.length > CONFIG.PARTICLE_TRAIL_MAX) {
                        particle.trail.shift();
                    }
                    
                    // 입자 이동
                    particle.x += vector.x * flowSpeed * 10;
                    particle.y += vector.y * flowSpeed * 10;
                    
                    // 경계 처리 및 생명주기 관리
                    this.handleParticleBounds(particle);
                });
            }
            
            handleParticleBounds(particle) {
                const outOfBounds = particle.x < 0 || particle.x > this.width || 
                                   particle.y < 0 || particle.y > this.height;
                
                particle.life--;
                
                if (outOfBounds || particle.life <= 0) {
                    Object.assign(particle, this.createParticle());
                }
            }
            
            draw(ctx) {
                this.particles.forEach(particle => {
                    this.drawParticleTrail(ctx, particle);
                    this.drawParticle(ctx, particle);
                });
                ctx.globalAlpha = 1.0;
            }
            
            drawParticleTrail(ctx, particle) {
                if (particle.trail.length <= 1) return;
                
                ctx.strokeStyle = particle.color + '80';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.6;
                
                ctx.beginPath();
                particle.trail.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
            }
            
            drawParticle(ctx, particle) {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = 1.0;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            getActiveCount() {
                return this.particles.filter(p => p.life > 0).length;
            }
        }

        // 메인 시각화 클래스
        class VectorFieldVisualizer {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.params = {
                    fieldType: 'gradient',
                    strength: 1.0,
                    particleCount: 200,
                    flowSpeed: 0.1,
                    isAnimating: true
                };
                
                this.vectorData = [];
                this.fieldData = [];
                this.time = 0;
                this.animationId = null;
                this.vegaCharts = {
                    fieldStats: null,
                    vectorField: null,
                    vectorArrows: null
                };
                
                this.particleSystem = null;
                
                this.init();
            }
            
            init() {
                this.initCanvas();
                this.setupControls();
                this.setupFieldButtons();
                this.initVegaCharts();
                this.animate();
            }
            
            initCanvas() {
                const resizeCanvas = () => {
                    const canvasArea = document.querySelector('.canvas-area');
                    const rect = canvasArea.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;
                    
                    this.canvas.width = rect.width * dpr;
                    this.canvas.height = rect.height * dpr;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    
                    this.ctx.scale(dpr, dpr);
                    
                    this.width = rect.width;
                    this.height = rect.height;
                    this.centerX = this.width / 2;
                    this.centerY = this.height / 2;
                    
                    console.log(`Canvas resized to: ${this.width}x${this.height}`);
                    
                    this.generateVectorField();
                    this.initParticleSystem();
                };
                
                setTimeout(resizeCanvas, 100);
                window.addEventListener('resize', () => setTimeout(resizeCanvas, 100));
            }
            
            initParticleSystem() {
                this.particleSystem = new ParticleSystem(this.width, this.height);
                this.particleSystem.initParticles(this.params.particleCount);
            }
            
            setupControls() {
                const controlConfig = [
                    { param: 'strength', element: 'strength', display: 'strengthValue' },
                    { param: 'particleCount', element: 'particleCount', display: 'particleCountValue' },
                    { param: 'flowSpeed', element: 'flowSpeed', display: 'flowSpeedValue' }
                ];
                
                controlConfig.forEach(config => {
                    const element = document.getElementById(config.element);
                    const display = document.getElementById(config.display);
                    
                    element.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.params[config.param] = value;
                        display.textContent = value;
                        
                        if (config.param === 'particleCount') {
                            this.particleSystem?.initParticles(value);
                        }
                    });
                    
                    display.textContent = element.value;
                });
                
                this.setupAnimationControls();
            }
            
            setupAnimationControls() {
                const playPauseBtn = document.getElementById('playPause');
                const resetBtn = document.getElementById('reset');
                
                playPauseBtn.addEventListener('click', () => {
                    this.params.isAnimating = !this.params.isAnimating;
                    playPauseBtn.textContent = this.params.isAnimating ? '⏸️ 일시정지' : '▶️ 재생';
                    playPauseBtn.classList.toggle('active', this.params.isAnimating);
                });
                
                resetBtn.addEventListener('click', () => {
                    this.particleSystem?.initParticles(this.params.particleCount);
                    this.time = 0;
                });
            }
            
            setupFieldButtons() {
                const buttons = document.querySelectorAll('.field-btn');
                
                buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        this.setActiveField(button, buttons);
                        this.params.fieldType = button.dataset.field;
                        this.onFieldChange();
                    });
                });
            }
            
            setActiveField(activeButton, allButtons) {
                allButtons.forEach(b => b.classList.remove('active'));
                activeButton.classList.add('active');
            }
            
            onFieldChange() {
                this.generateVectorField();
                this.particleSystem?.initParticles(this.params.particleCount);
                this.updateVegaCharts();
            }
            
            getVectorAt(x, y) {
                return VectorFieldMath.getVectorAt(
                    x, y, this.centerX, this.centerY, 
                    this.params.fieldType, this.params.strength, this.time
                );
            }
            
            generateVectorField() {
                this.vectorData = [];
                this.fieldData = [];
                
                const step = Math.max(this.width, this.height) / CONFIG.VECTOR_DENSITY;
                
                for (let x = step; x < this.width; x += step) {
                    for (let y = step; y < this.height; y += step) {
                        const vector = this.getVectorAt(x, y);
                        const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                        
                        this.vectorData.push({
                            x, y,
                            vx: vector.x,
                            vy: vector.y,
                            magnitude,
                            angle: Math.atan2(vector.y, vector.x) * 180 / Math.PI
                        });
                        
                        this.fieldData.push({ x, y, value: magnitude });
                    }
                }
            }
            
            drawVectorShafts() {
                this.ctx.strokeStyle = CONFIG.COLORS.ARROW_SHAFT;
                this.ctx.lineWidth = 1.5;
                
                this.vectorData.forEach(data => {
                    const dx = data.vx * CONFIG.ARROW_SHAFT_LENGTH;
                    const dy = data.vy * CONFIG.ARROW_SHAFT_LENGTH;
                    
                    if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                        this.drawArrowShaft(data.x, data.y, dx, dy);
                    }
                });
            }
            
            drawArrowShaft(x, y, dx, dy) {
                const length = Math.sqrt(dx * dx + dy * dy);
                if (length < 1) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x + dx, y + dy);
                this.ctx.stroke();
            }
            
            draw() {
                if (!this.width || !this.height) return;
                
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                this.drawVectorShafts();
                
                this.particleSystem?.updateParticles(
                    (x, y) => this.getVectorAt(x, y),
                    this.params.flowSpeed,
                    this.params.isAnimating
                );
                this.particleSystem?.draw(this.ctx);
                
                // 주기적 업데이트
                if (this.time % CONFIG.INFO_UPDATE_RATE === 0) {
                    this.updateFieldInfo();
                }
            }
            
            initVegaCharts() {
                this.initFieldStatsChart();
                this.initVectorFieldChart();
                this.initVectorArrowsChart();
            }
            
            initFieldStatsChart() {
                const spec = this.createFieldStatsSpec();
                this.embedVegaChart('#vegaFieldStats', spec, 'fieldStats');
            }
            
            initVectorFieldChart() {
                const spec = this.createVectorFieldSpec();
                this.embedVegaChart('#vegaVectorField', spec, 'vectorField');
            }
            
            initVectorArrowsChart() {
                const spec = this.createVectorArrowsSpec();
                this.embedVegaChart('#vegaVectorArrows', spec, 'vectorArrows');
            }
            
            embedVegaChart(selector, spec, chartName) {
                vegaEmbed(selector, spec, { actions: false })
                    .then(result => {
                        this.vegaCharts[chartName] = result;
                        console.log(`${chartName} 차트 초기화 완료`);
                        if (this.vectorData?.length > 0) {
                            this.updateVegaCharts();
                        }
                    })
                    .catch(error => {
                        console.error(`${chartName} 차트 초기화 실패:`, error);
                    });
            }
            
            createFieldStatsSpec() {
                return {
                    "$schema": "https://vega-lite.org/v4/schema/",
                    "width": 250,
                    "height": 120,
                    "title": {
                        "text": "벡터 강도 분포",
                        "fontSize": 14,
                        "color": "white",
                        "fontWeight": "bold"
                    },
                    "data": {"name": "fieldData"},
                    "layer": [
                        {
                            "mark": {
                                "type": "bar", 
                                "color": "#3282B8",
                                "opacity": 0.8,
                                "cornerRadius": 2
                            },
                            "encoding": {
                                "x": {
                                    "bin": {"maxbins": 10},
                                    "field": "value",
                                    "title": "벡터 강도",
                                    "axis": {"labelColor": "white", "titleColor": "white", "labelFontSize": 10}
                                },
                                "y": {
                                    "aggregate": "count",
                                    "title": "빈도",
                                    "axis": {"labelColor": "white", "titleColor": "white", "labelFontSize": 10}
                                }
                            }
                        },
                        {
                            "mark": {
                                "type": "rule",
                                "color": "#FF6B6B",
                                "size": 3,
                                "strokeDash": [4, 4]
                            },
                            "encoding": {
                                "x": {
                                    "aggregate": "mean",
                                    "field": "value"
                                }
                            }
                        }
                    ],
                    "config": this.getVegaBaseConfig()
                };
            }
            
            createVectorFieldSpec() {
                return {
                    "$schema": "https://vega-lite.org/v4/schema/",
                    "width": 250,
                    "height": 160,
                    "title": {
                        "text": "벡터 방향 & 강도",
                        "fontSize": 14,
                        "color": "white",
                        "fontWeight": "bold"
                    },
                    "data": {"name": "vectorData"},
                    "mark": {
                        "type": "point", 
                        "size": 60,
                        "opacity": 0.8,
                        "stroke": "white",
                        "strokeWidth": 0.5
                    },
                    "encoding": {
                        "x": {
                            "field": "angle",
                            "type": "quantitative",
                            "scale": {"domain": [-180, 180]},
                            "title": "방향 (도)",
                            "axis": {"labelColor": "white", "titleColor": "white", "labelFontSize": 10}
                        },
                        "y": {
                            "field": "magnitude",
                            "type": "quantitative",
                            "title": "강도",
                            "axis": {"labelColor": "white", "titleColor": "white", "labelFontSize": 10}
                        },
                        "color": {
                            "field": "magnitude",
                            "type": "quantitative",
                            "scale": {
                                "scheme": "plasma",
                                "range": ["#3282B8", "#FF6B6B", "#FFB74D"]
                            },
                            "legend": {
                                "title": "강도",
                                "titleColor": "white",
                                "labelColor": "white",
                                "titleFontSize": 10,
                                "labelFontSize": 9
                            }
                        },
                        "size": {
                            "field": "magnitude",
                            "type": "quantitative",
                            "scale": {"range": [30, 120]}
                        }
                    },
                    "config": this.getVegaBaseConfig()
                };
            }
            
            createVectorArrowsSpec() {
                return {
                    "$schema": "https://vega.github.io/schema/vega/v5.json",
                    "width": {"signal": "containerSize()[0]"},
                    "height": {"signal": "containerSize()[1]"},
                    "padding": 0,
                    "autosize": "none",
                    "background": "transparent",
                    "data": [{"name": "vectorData"}],
                    "marks": [{
                        "type": "symbol",
                        "from": {"data": "vectorData"},
                        "encode": {
                            "enter": {
                                "fill": {"value": CONFIG.COLORS.ARROW_HEAD},
                                "stroke": {"value": CONFIG.COLORS.ARROW_HEAD},
                                "strokeWidth": {"value": 0.5},
                                "size": {"value": 25}
                            },
                            "update": {
                                "x": {"signal": `datum.x + datum.vx * ${CONFIG.ARROW_SHAFT_LENGTH}`},
                                "y": {"signal": `datum.y + datum.vy * ${CONFIG.ARROW_SHAFT_LENGTH}`},
                                "angle": {"signal": "atan2(datum.vy, datum.vx)"},
                                "opacity": {"signal": "sqrt(datum.vx * datum.vx + datum.vy * datum.vy) > 0.05 ? 0.8 : 0"}
                            }
                        },
                        "transform": [{"type": "symbol", "shape": "triangle-up"}]
                    }]
                };
            }
            
            getVegaBaseConfig() {
                return {
                    "background": "transparent",
                    "text": {"color": "white", "fontSize": 10},
                    "axis": {
                        "labelColor": "white", 
                        "titleColor": "white", 
                        "domainColor": "white",
                        "gridColor": "rgba(255,255,255,0.1)"
                    },
                    "title": {"color": "white", "fontSize": 14}
                };
            }
            
            updateVegaCharts() {
                if (!this.vectorData?.length || !this.fieldData?.length) {
                    console.log('벡터 데이터가 준비되지 않았습니다.');
                    return;
                }

                const cleanVectorData = this.filterValidData(this.vectorData, ['magnitude', 'angle']);
                const cleanFieldData = this.filterValidData(this.fieldData, ['value']);

                if (!cleanVectorData.length || !cleanFieldData.length) {
                    console.log('유효한 데이터가 없습니다.');
                    return;
                }

                this.updateVegaChart('fieldStats', 'fieldData', cleanFieldData);
                this.updateVegaChart('vectorField', 'vectorData', cleanVectorData);
                this.updateVegaChart('vectorArrows', 'vectorData', cleanVectorData);
                
                this.updateFieldInfo();
            }
            
            filterValidData(data, fields) {
                return data.filter(d => {
                    if (!d) return false;
                    return fields.every(field => !isNaN(d[field]) && isFinite(d[field]));
                });
            }
            
            updateVegaChart(chartName, dataName, data) {
                const chart = this.vegaCharts[chartName];
                if (!chart) return;
                
                try {
                    chart.view
                        .remove(dataName, () => true)
                        .insert(dataName, data)
                        .run();
                } catch (error) {
                    console.warn(`${chartName} 차트 업데이트 실패:`, error);
                }
            }
            
            updateFieldInfo() {
                if (!this.vectorData.length) return;
                
                const magnitudes = this.vectorData.map(d => d.magnitude);
                const stats = this.calculateFieldStats(magnitudes);
                const activeParticles = this.particleSystem?.getActiveCount() || 0;
                
                const info = `${this.getFieldDescription()} | 평균: ${stats.avg.toFixed(2)} | 최대: ${stats.max.toFixed(2)}`;
                
                document.getElementById('fieldInfo').textContent = info;
                document.getElementById('activeParticles').textContent = activeParticles;
            }
            
            calculateFieldStats(magnitudes) {
                const sum = magnitudes.reduce((a, b) => a + b, 0);
                return {
                    avg: sum / magnitudes.length,
                    max: Math.max(...magnitudes),
                    min: Math.min(...magnitudes)
                };
            }
            
            getFieldDescription() {
                const descriptions = {
                    'gradient': '∇f - 그래디언트',
                    'divergence': '∇·F - 발산',
                    'curl': '∇×F - 회전',
                    'uniform': 'F = const - 균등',
                    'saddle': 'Saddle - 새들점',
                    'wave': 'Wave - 파동'
                };
                return descriptions[this.params.fieldType] || 'Unknown';
            }
            
            animate() {
                this.draw();
                
                if (this.params.isAnimating) {
                    this.time += 1;
                    
                    if (this.time % CONFIG.VEGA_UPDATE_RATE === 0) {
                        this.updateVegaCharts();
                    }
                }
                
                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }
        
        // 초기화
        let vectorField;
        window.addEventListener('load', () => {
            vectorField = new VectorFieldVisualizer();
        });
    </script>
</body>
</html>
